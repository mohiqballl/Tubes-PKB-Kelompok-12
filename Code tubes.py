# -*- coding: utf-8 -*-
"""Kelompok12_TUBES.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15uoGtj491lCC8WfH6br45uf-YQ2ovEX7
"""

# Mengimpor libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# Muat dataset
df = pd.read_csv('data.csv')

# Menampilkan pratinjau set data
print(df.head(10))
print("")
print(df.tail(10))
print("")
print(df.describe())

A# Plot 1: Distribusi CondensedBinary2DGeometry
plt.figure(figsize=(14, 6))
plt.subplot(1, 3, 1)
sns.histplot(df['CondensedBinary2DGeometry'], kde=True, color='blue')
plt.title('Distribution of CondensedBinary2DGeometry')

# Plot 2: Distribusi BandGapLocation
plt.figure(figsize=(14, 6))
plt.subplot(1, 3, 2)
sns.histplot(df['BandGapLocation'], kde=True, color='green')
plt.title('Distribution of BandGapLocation')

# Plot 3: Distribusi BandGapWidth
plt.figure(figsize=(14, 6))
plt.subplot(1, 3, 3)
sns.histplot(df['BandGapWidth'], kde=True, color='red')
plt.title('Distribution of BandGapWidth')

# Plot 1: CondensedBinary2DGeometry vs BandGapLocation
plt.figure(figsize=(14, 6))
plt.subplot(1, 2, 1)
sns.scatterplot(x='CondensedBinary2DGeometry', y='BandGapLocation', data=df, color='green')
plt.title('CondensedBinary2DGeometry vs BandGapLocation')

# Plot 2: CondensedBinary2DGeometry vs BandGapWidth
plt.figure(figsize=(14, 6))
plt.subplot(1, 2, 2)
sns.scatterplot(x='CondensedBinary2DGeometry', y='BandGapWidth', data=df, color='red')
plt.title('CondensedBinary2DGeometry vs BandGapWidth')

# Memvisualisasikan plot kotak untuk kolom numerik
num_cols = df.select_dtypes(include=['int', 'float']).columns
plt.figure(figsize=(14, 5))

for i, col in enumerate(num_cols):
    plt.subplot((len(num_cols) + 2) // 3, 3, i + 1)
    sns.boxplot(x=df[col])
    plt.title(f'Boxplot for Column: {col}')

plt.tight_layout()
plt.show()

# Periksa korelasi
correlation_matrix = df.corr()
print("\nCorrelation Matrix:")
print(correlation_matrix)

# Memvisualisasikan korelasi heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('Correlation Heatmap')
plt.show()

# Periksa nilai yang hilang dan duplikat
print("\nMissing Values for Each Column:")
print(df.isnull().sum())

print("\nNumber of Duplicate Rows:")
print(df.duplicated().sum())

# Hapus baris duplikat
df_cleaned = df.drop_duplicates()
print("Rows before removing duplicates:", len(df))
print("Rows after removing duplicates:", len(df_cleaned))

# Menyimpan data yang telah dibersihkan ke file CSV baru
df_cleaned.to_csv('data_cleaned.csv', index=False)

# Menormalkan fitur dan variabel target menggunakan MinMaxScaler
scaler = MinMaxScaler()
df[['CondensedBinary2DGeometry', 'BandGapLocation', 'BandGapWidth']] = scaler.fit_transform(df[['CondensedBinary2DGeometry', 'BandGapLocation', 'BandGapWidth']])
print("\nDataset After Normalization:")
print(df.head())

# Pisahkan set data menjadi fitur (X) dan target (y1, y2)
X = df[['CondensedBinary2DGeometry']]
y1 = df['BandGapLocation']
y2 = df['BandGapWidth']

# Membagi data ke dalam set pelatihan dan pengujian
X_train, X_test, y1_train, y1_test, y2_train, y2_test = train_test_split(X, y1, y2, test_size=0.2, random_state=42)

# Membuat dan melatih model regresi linier
model1 = LinearRegression()
model1.fit(X_train, y1_train)

model2 = LinearRegression()
model2.fit(X_train, y2_train)

# Memprediksi nilai target untuk set pengujian
y1_pred = model1.predict(X_test)
y2_pred = model2.predict(X_test)

# Mengevaluasi model untuk BandGapLocation
mae1 = mean_absolute_error(y1_test, y1_pred)
mse1 = mean_squared_error(y1_test, y1_pred)
r2_1 = r2_score(y1_test, y1_pred)

# Mengevaluasi model untuk BandGapLocation
mae2 = mean_absolute_error(y2_test, y2_pred)
mse2 = mean_squared_error(y2_test, y2_pred)
r2_2 = r2_score(y2_test, y2_pred)

# Menampilkan hasil evaluasi
print("Model Evaluation for BandGapLocation:")
print(f"Mean Absolute Error (MAE): {mae1}")
print(f"Mean Squared Error (MSE): {mse1}")
print(f"R-squared: {r2_1}")

print("\nModel Evaluation for BandGapWidth:")
print(f"Mean Absolute Error (MAE): {mae2}")
print(f"Mean Squared Error (MSE): {mse2}")
print(f"R-squared: {r2_2}")

# Inisialisasi model LinearRegression
linear_reg = LinearRegression()

# Tentukan pipeline untuk prapemrosesan dan pemodelan
pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('regressor', linear_reg)
])

# Penyetelan hiperparameter untuk Regresi Linier
param_grid_lr = {
    'regressor__fit_intercept': [True, False]
}

# GridSearchCV untuk target1
grid_search_lr1 = GridSearchCV(estimator=pipeline, param_grid=param_grid_lr, cv=5, scoring='neg_mean_squared_error', n_jobs=-1)
grid_search_lr1.fit(X_train, y1_train)

# GridSearchCV untuk target2
grid_search_lr2 = GridSearchCV(estimator=pipeline, param_grid=param_grid_lr, cv=5, scoring='neg_mean_squared_error', n_jobs=-1)
grid_search_lr2.fit(X_train, y2_train)

# Menampilkan hasil GridSearchCV
print("GridSearchCV Results for BandGapLocation:")
print("Best Parameters:", grid_search_lr1.best_params_)
print("Best MSE:", -grid_search_lr1.best_score_)

print("\nGridSearchCV Results for BandGapWidth:")
print("Best Parameters:", grid_search_lr2.best_params_)
print("Best MSE:", -grid_search_lr2.best_score_)

# Plot nilai Aktual vs Prediksi untuk BandGapLocation
plt.subplot(1, 2, 1)
plt.scatter(X_test, y1_test, color='blue', label='Actual')
plt.plot(X_test, y1_pred, color='red', label='Predicted')
plt.title('BandGapLocation: Actual vs Predicted')
plt.xlabel('CondensedBinary2DGeometry')
plt.ylabel('BandGapLocation')
plt.legend()

# Plot nilai Aktual vs Prediksi untuk BandGapWidth
plt.subplot(1, 2, 2)
plt.scatter(X_test, y2_test, color='blue', label='Actual')
plt.plot(X_test, y2_pred, color='red', label='Predicted')
plt.title('BandGapWidth: Actual vs Predicted')
plt.xlabel('CondensedBinary2DGeometry')
plt.ylabel('BandGapWidth')
plt.legend()

plt.tight_layout()
plt.show()

# Memprediksi BandGapLocation menggunakan model
y1_pred = model1.predict(X)

# Hitung residu untuk BandGapLocation
residual1 = y1 - y1_pred
print("Residuals for BandGapLocation:")
print(residual1)

# Membuat dan menyesuaikan model regresi linier untuk BandGapWidth
model2.fit(X, y2)

# Membuat dan menyesuaikan model regresi linier untuk BandGapWidth
y2_pred = model2.predict(X)

# Hitung residu untuk BandGapWidth
residual2 = y2 - y2_pred
print("\nResiduals for BandGapWidth:")
print(residual2)
